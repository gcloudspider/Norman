/**
* Create Date:2016年01月23日 星期六 14时54分40秒
* 
* Author:Norman
* 
* Description: 
*/

####进程对内存分配和管理:
    从用户向内核看:
        逻辑地址(逻辑地址段机制转化成线性地址)
        线性地址(线性地址又经过页机制转化为物理地址)
        物理地址

####进程内存空间:
    Linux操作系统采用虚拟内存管理技术.每个进程各自互不干涉的进程地址空间.
    该空间块大小为4G线性虚拟空间
    4G进程地址空间分为:
        用户空间(0~3G):
            1.用户进程通常只能访问用户空间虚拟地址,不能访问内核空间虚拟地址
            2.用户空间进程切换,用户空间就会跟着变化
            3.每个进程用户空间独立,互不干扰的
        内核空间(3G~4G):
            1.用户进程进行系统调用时可以访问内核空间
            2.内核空间凡内核负责映射,不会随进程改变,固定的,内核空间地址有自己对应页表,用户进程各有不同页表
    
####进程内存管理:
    进程内存管理的对象是进程线性地址空间上的内存镜像!
    内存镜像:
        就是进程使用的虚拟内存区域
    进程虚拟空间:
        1.是32或64位独立连续区间地址空间.
        2.虚拟空间被划分为许多大小可变(4096倍数)内存区域,这些区域在进程线性地址中有序排列
        3.划分原则:将访问属性一致的地址空间存放在一起。(可读,可写,可执行)

    Linux内核中对应进程内存区域数据结构是:vm_area_struct
    内核将每个内存区域作为一个单独的内存对象管理,相应操作也一致,采用面向对象方法使VMA结构体可以代表多种类型内存区域

    1.vm_area_struct描述进程地址空间基本管理单元.
    2.vm_area_struct结构以链表形式链接关联不同内存区域
    3.为方便查找,内核又以红黑树形式组织内存区域,以便降低搜索耗时,并存两种形式,并非冗余
        链表用于需要遍历全部节点时用。
        红黑树形组织内存区域,降低内存区域上各种不同操作都能获得高性能

    进程地址空间对应描述结构是"内存描述符结构"它表示进程全部地址空间
    包含了进程地址空间有关全部信息,当然包含进程的内存区域

####进程内存分配与回收:
    1.内存申请获得不是实际内存,而是虚拟内存(最终会归结到do_mmap()函数上) brk调用被单独以系统调用实现
    2.内核使用do_mmap()函数创建一个新的线性地址区间.
    3.释放一个内存区域使用do_ummap() 销毁对应内存区域

####虚拟地址转为物理地址:
    1.申请内存仅是对一个新的线性地址区间使用权.
    2.物理内存只有当进程去访问新获取的虚拟地址时,才会由"请求页机制"产生缺页异常,从而进入分配实际页面的例程
    3.请求页机制---会告诉内核真正为进程分配物理页,并建立对应页表,这虚拟地址才映射到物理内存上。

####系统物理内存管理:
    应用程序操作对象是映射到物理内存之上虚拟内存,但处理器直接操作的是物理内存
    应用程序---->虚拟地址---->物理地址---->CPU解析地址访问请求(转换查询页表)

    地址转换:将虚拟地址分段,使每段虚地址作为一个索引指向页表,页表项则指向下一级页表或指向最终的物理页面.

    每个进程都有自己的页表,进程描述符pgd域指向就是进程页全局目录


####物理内存管理(页管理):
    Linux内核管理物理内存通过分页机制实现:
        1.将整个内存划分成无数个4K大小的页(分配回收基本单位)
        2.实际使用内存分配连续内存块,页表不需要更改
        3.采用"伙伴"关系来管理空闲页面(最小单位只能是2的幂倍页面大小)
        4.内核中分配空闲页基本函数:get_free_page/get_free_pages 分配单页或分配指定页面
            4.1:get_free_page在内核中分配内存(不同于malloc利用堆动态分配,实际调用brk()系统调用)
            4.2:brk()系统调用作用是扩大或缩小进程堆空间
            4.3:现有内存区域不够容纳堆空间，以页大小倍数为单位扩张或收缩对应的内存区域
            4.4:brk值并非以页面大小为倍数修改,而是按实际请求修改
            4.5:malloc可以以字节为单位分配,但在内核以页为单位为配的
        5.物理页由页结构struct page描述,系统所有页都存储在数组mem_map[]中 通过该数据找到系统中每一页
        6.空闲页由伙伴关系组织的空闲页链表(free_area[MAX_ORDER])来索引

![](./mmu.gif)


####内核内存使用:
    内核物理内存最小分配单位---页
    内核使用内存小于一页内存(存放文件描述符,进程描述符 虚拟内存区域描述符等)
    
    Slab分配器:(核心思想---存储池)
        1.Linux使用Slab分配器把内存片段看作对象,使用完后,缓存到存储池留下次使用(避免频繁创建销毁)
        2.主要目的:减少对伙伴算法调用次数,利用硬件缓存提高访问速度
        3.Slab没有脱离伙伴关系独立存在内存分配方式，建立在页基础上(将页面撕成众多小内存块以供分配)
        4.slab中对象分配和销毁使用kmem_cache_alloc与kmem_cache_free

    Kmalloc:
        1.Slab不仅只用来存放内核专用结构体,还用来处理内核对小块内存请求
        2.内核中小于一页小内存请求才通过slab分配器提供接口Kmalloc来完成(32到131072字节)
        3.内核看来kmalloc看成get_free_page(s)补充



####内核非连续内存分配(Vmalloc):
    1.分片:
        2.1:外部分片:
            系统虽有足够内存,但却是分散碎片,无法満足大块"连续内存"的需求
        2.2:内部分片:
            満足小段内存区需要,不得不分配一大区域连续内存给它,从而造成空间浪费
    
    2.伙伴算法，slab技术都是防止"分片":
        把内存块按大小分组管理,一定程度上减轻了外部分片危害.(减轻,未彻底消除)
    
    3.Slab分配器:
        使得一个页面包含众多小块内存可独立被分配使用,避免内部分片,节约空闲内存

    4.内存映射(不一定连续物理内存上):
        4.1:允许内核程序在内核地址空间中分配虚拟地址,同样利用页表将虚拟地址映射到分散内存页上,完美解决内核内存使用中外部分片问题
        4.2:内核使用vmalloc分配内核虚拟内存(不同于kmalloc 可以分配较Kmalloc大得多内存空间--远大于128K 但必须是页大小倍数)
        4.3:相比Kmalloc Vmalloc需对内核虚拟地址重映射,必须更新内核页表,分配效率低一些(用空间换时间)
        4.4:内核也有init_mn的mm_struct结构来描述内核地址空间(页表项pdg=sqapper_pg_dir包含系统内核空间映射关系)
        4.5:vmalloc分配内核虚拟地址必须更新内核页表,kmalloc或get_free_page由于分配连续内存,所以不需要更新内核页表

    5.vmalloc分配内核虚拟内存与kmalloc/get_free_page分配内核虚拟内存位于不同区间(不会重叠)
        5.1:进程空间地址:0-3G
        5.2:从3G到vmalloc_start段地址是物理内存映射区域(内核镜像 物理页面表mem_map)
            5.2.1:如系统内存64M那3G----3G+64M就是内存映射到物理内存
            5.2.2:物理内存映射区与vmalloc_start期间还存在8M大小gap防止跃界
        5.3:vmalloc_end位置接近4G
            5.3.1:最后位置系统会保留一片128K大小区域用于专用页面映射 

####内存分布:
    1.get_free_page或Kmalloc函数所分配连续内存都陷于物理映射区域(返回内核虚拟地址与实际物理地址仅相差一个偏移量)
    2.内核virt_to_phys()函数将内核虚拟空间中的物理映射区地址转化为物理地址
    3.vmalloc分配地址限于vmalloc_start与vmalloc_end之间 
    4.每一块vmalloc分配内核虚拟内存对应vm_struct结构体,不同内核虚拟地址被4K大小空间区间隔,防止越界
