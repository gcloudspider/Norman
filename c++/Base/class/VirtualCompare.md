/**
* Create Date:2016年03月11日星期五 08:26:49
* 
* Author:Norman
* 
* Description: 
*/

####有无虚函数对比:
####1.一般继承(无虚函数覆盖)
####![](./image/Drawing1.jpg)
####![](./image/vtable2.JPG)
    1.虚函数按照顺序放于表中
    2.父类的虚函数在子类的虚函数前面

####2.一般继承(有虚函数覆盖)
####![](./image/Drawing2.jpg)
####![](./image/vtable3.JPG)
    1.覆盖的f()函数被放到虚表中原来父类虚函数的位置
    2.没有被覆盖的函数依旧

####3.多重继承(无虚函数覆盖)
####![](./image/Drawing3.jpg)
####![](./image/vtable4.JPG)
    1.每个父类都有自己的虚表
    2.子类的成员函数被放到第一个父类的表中(按声明顺序来判断)
    3.目的是为了解决不同的父类类型的指针指向同一个子类实例,而能够调用到实际的函数

####4.多重继承(有虚函数覆盖)
####![](./image/Drawing4.jpg)
####![](./image/vtable5.jpg)
    三个父类虚函数表中的f()位置被替换成子类的函数指针,可以任一静态类型的父类来指向子类,并调用子类f()函数


####虚函数弊端
####[1.通过父类指针访问子类自己的虚函数](./MultiInheritVtable.cpp)
        任何想使用父类指针调用子类未覆盖父类的成员函数行为都会被视为非法,
        但在运行时可以通过指针的方式访问虚函数表来达到违反C++语义的行为
    
####[2.访问non-public的虚函数](./VirtualNoPublic.cpp)
        如果父类的虚函数是private或protected的,这些非public虚函数同样存在于虚函数表中,可以使用访问虚函数表的方式来访问这些non-public的虚函数

