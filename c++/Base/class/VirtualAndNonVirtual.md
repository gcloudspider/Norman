/**
* Create Date:2016年03月 9日星期三 19:03:54
* 
* Author:Norman
* 
* Description: 
*/

####虚函数与非虚函数调用方式:
    1.非虚成员函数是静态确定的(编译时就会被静态地选择)
    2.虚成员函数是动态确定的(运行时才被动态地选择) --- 该选对基于对象类型,而不是指向该对象的指针或引用的类型 (动态绑定)


####动态绑定:
    1.如果对象有一个或多个虚函数,编译器将一个隐藏的指针放入对象--- vptr
    2.vptr指向一个全局表 vtbl
    3.分发一个虚函数时,运行时系统跟随对象的vptr找到类的vtbl 然后跟随vtbl中适当的项找到方法的代码.

####虚函数对象的空间开销
    每个对象一个额外的指针,加上每个方法一个额外的指针

####虚函数对象的时间开销
    和普通函数调用相比较,虚函数调用需要额外步骤 
    (不包含多继承/虚继承/RTTI机制/page fault/)

####虚函数和重载区别:
    1.函数重载在编译期间就可确定下来我们要使用的函数---可预测的
    2.而虚函数在运行时刻才能确定到具体的函数----不可预测的(晚绑定/函数覆盖)

####虚函数遭遇内联:
    虚函数不可能是内联函数原因?
    1.虚函数是运行时机制    -----  内联函数特性是编译时机制
    2.声明一个内联的虚函数会使程序在执行时产生多个函数拷贝,将导致大量空间浪费

    很多情况下,虚函数都是静态确定的--特别是当派生类的虚方法调用基类的方法时 --- 封装
    例子:
        派生类的析构函数引起基类的析构函数的调用,
        除了最初的函数,其他函数都是静态确定的,如果不确定基类析构函数为内联,就不很发挥这一优点
        特别在继承层次很深,并且许多对象被析构的时候,对虚函数进行内联毫无疑问会大大提高程序的运行效率

####[虚函数与内联例子](./VirtualAndInline.cpp)
####[虚函数开销](./VirtualFunction.md)
####[虚析构函数时机](./VirtualDestructor.md)
####[虚构造函数](./VirtualStructor.md)

####为什么成员函数默认不是virtual
    因为很多类并不是被设计作为基类.(如:复数类)
    一个包含虚函数的类的对象,要占用更多空间以实现虚拟函数调用机制 --- 往往是每个对象占用一个字(涉及和其它语言的数据兼容可能导致麻烦 如 C或Fortran语言)
####成员函数的模板可不可以是Virtual
    ANSI/ISO标准说 一个成员函数模板不可以是virtual 
