-###################################################
-#### Create Date:2016年01月14日 星期四 08时44分15秒
-####
-####Author:Norman
-####
-####Description: 链接器作用
-###################################################
-
-####链接器作用:
-    根据上下文提供的目标文件结构图,"填充图中的空白"
-
-    链接器,把所有相关目标文件集合都统一存放在一个方便访问的地方(库)
-
-    动态库在不同程序中使用时,将被映射成不同的地址空间,也就是说库中所有的函数和变量在不同程序中有不同的地址,如果所有访问该地址都使用相对地址,而不是绝对地址
-
-    所有绝对地址都必须加一个合适的偏移量-----重定位
-
-
-####静态库:
-    UNIX系统中,使用ar命令生成静态库,并以.a作为文件扩展名  lib作为文件名前缀
-    链接时使用-l选项  用于告诉链接器链接时所需要的库
-
-    Windows平台,静态库扩展名为.LIB  可用.LIB工具生成
-
-    链接器将所有目标文件集链接到一起的过程中,会为所有当前未解决的符号构建一张"未解决符号表",当所有显示指定的目标文件都处理完毕时,链接器将到库中去寻找"未解决符号表"中剩余的符号
-    如果未解决的符号在库里其中一个目标中定义,那么这个文件将加入链接过程
-
-####注意:
-    1.从库中导入文件粒度问题:
-        1.1:如果某个特定符号定义是必须的,那么包含该符号定义的整个目标文件都要被导入
-    2.库处理顺序:
-        2.1:链接器按命令行从左到右的顺序进行处理，只有前一个库处理结束了，才会继续处理下一个库。
-
-####共享库:
-    UINX系统中为.so
-    Windows系统中为.dll
-    Mac OSX系统中为.dylib
-
-    此类库,链接器没有必要将所有符号都关联起来(做标签),直到程序运行时才进行处理
-    main函数开始前,有一个小型链接器ld.so 将负责检查标签内容，并完成最后一个步骤,导入库里代码,并将所有符号关联在一起
-
-
-####共享库与静态库差异:(链接的粒度)
-    1.程序中只引用了共享库里某个符号那么整个共享库都映射到程序地址空间中
-    2.静态库只会导入与该符号相关的那个目标文件
-    
-
-####windows DLLS
-    1.导出符号信息方法:
-        1.1:在源代码中为符号声明关键字 declspec(dllexport)
-        1.2:使用链接器LINK.EXE提供的选项:/export:_symbol_to_export
-        1.3:使用链接器的/DEF:_def_file_这一选项,可用于导入模块定义文件(.DEF) 该文件中有一部分名为EXPORTS
-
-    2.LIB及其它库相关文件
-        链接器在将各符号链接到一起时所需要的导出符号信息,并不包含在DLL文件中,而是包含在与之相对应的.LIB文件中
-        与某个DLL库关联的.LIB文件列出了该DLL库中(导出符号)以及符号地址，甩有使用这个DLL库的程序都必须同时访问它的.LIB文件才能保证所有符号正常链接
-
-    3.链接输出文件:
-        libary.DLL:库的实现代码,可实时导入每个使用该库的可执行程序
-        libary.LIB:导入库文件,给定了DLL文件中的符号及地址表,只有当DLL导出某些符号时才会产生这个文件。如果没有符号导出.LIB文件没有存在必要,所有使用该库程序在链接阶段都必须用到该文件
-        libary.EXP:动态库在链接期时的一个"导出文件" 当链接中二进制文件出现循环依赖,该文件就泒上用场了
-        libary.ILK:链接时指定/INCREMENTAL 选项---开启增量链接功能(该文件保存增量链接时相关状态,供动态为下次增量链接时使用)
-        libary.PDB:如果链接时指定了DEBUG选项。将生成程序数据库.包含所有调试信息
-        libary.MAP:如果链接时指定了/MAP选项,将生成描述整个库内部布局信息文件
-    4.链接时输入文件:
-        libary.LIB:导入库文件，给定链接时所需DLL文件中符号及地址列表
-        libary.LIB:静态库文件，包含链接时所需的系统目标文件集，使用.LIB文件时需区分静态库还是"导入库"
-        libary.DEF:模块定义文件，包含链接库各种细节给予控制权,包括符号导出
-        libary.EXP:动态库处于链接期的一个导出文件。
-        libary.ILK 增量链接状态文件
-        libary.RES:资源文件,包含执行过程中所需的各种GUI部件信息,这些信息包含在最终二进制文件中
-    5.导入符号:
-        在源代码加上__declspec(dllimport) 但由于C语言所有函数以及全局变量都在肯仅在头文件中声明一次。
-        DLL中包含函数和变量的定义的代码需要进行符号导出,但DLL以及的代码需要进行符号导入
-
-        解决方法:
-            在头文件中加预处理宏
-            \#ifdef EXPORTING_XYZ_DLL_SYMS
-            \#define XYZ_LINKAGE __declspec(dllexport)
-            \#else
-            \#define XYZ_LINKAGE __declspec(dllimport)
-            \#endif
-            XYZ_LINKAGE int xyz_exported_function(int x);
-            XYZ_LINKAGE extern int xyz_exported_variable;
-
-    6.循环依赖:
-        windows 要求在链接期必须是已解决符号
-        Unix 链接一个包含链接器不认识的未解决符号动态库是可行的.
-
-        Windows提供绕过相互依赖问题方法:
-            1.生成一个库X假链接。运行LIB.EXE 生成X.LIB 不会生成X.DLL 取而代之是X.EXP文件
-            2.以正常方式进行库Y的链接：使用上一步中生成的X.LIB 导出Y.DLL 和Y.LIB
-            3.以合适方式链接X 
