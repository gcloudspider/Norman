###################################################
#### Create Date:2016年01月15日 星期五 09时06分13秒
####
####Author:Norman
####
####Description: C++加入示意图
###################################################

####随着C++功能日趋复杂,链接器不得不加入对这些功能支持
    1.函数重载和命名改编(name mangling)
        1.1:函数重载(函数签名不同)
        链接器采用一种称为"命名改写"的方法来解决这一问题
        mangling:将函数签名相关的信息被"损坏"变成一种文本形式,成为链接器眼中符号的实际名称.不同函数签名将被"损坏"成不同的名称

        1.2:当C和C++代码混合编写时
            C++编译器生成的符号名称都经过改编处理
            C编译器生成符号名称就是它源文件中的名称
        避免该问题:C++采用extern "C"来声明和定义C语言函数.目的告诉C++编译器这个函数名不能被改变
        既可能因为相关的C代码需要调用C++函数的定义也可能因为相关C++代码需要调用C函数

        注意:extern "C" 链接声明对成员函数无效

	2.静态初始化
		C++比C多出影响链接器行为的功能是对象的构造函数
		构造函数是用于初始化对象内容.
		C++中,构造过程所需完成操作远比拷贝定值复杂,在程序开始正常运行这前,类层次体系中各种构造函数里的代码都必须提前执行
		编译器在每一个C++文件的目标文件中都保存了一些额外信息,(保存了某个文件所需的构造函数列表,在链接阶段,链接器把所有列表合成一张大表,通过一次次扫描该表来调用每个全局对象对应的构造函数)
		
	3.模板:
		模板的每一个实例化函数执行时使用的都是不同的机器码,
		因此在程序的链接阶段,编译器和链接器需要确保程序调用的每个模板实例函数都扩展出相应类型的程序代码
		(但对于未被调用的其他模板实例函数而言,不会有任何多余代码生成,这样可以避免程序代码过度膨胀)
		
		编译器和链接器切换:
			1.将每个实例函数代码展开(the sane way 普通方法)
				----每个目标文件中都会包含它所调用的所有模板函数的代码。
				目标函数将函数定义标记成"弱符号" 表示当链接器最终生成可执行程序时,将只留下所有重复定义的其中之一,剩余的定义都将弃之不用
				该方法缺点:每个目标文件都将占用更多磁盘空间
			2.将实例化操作延迟到链接阶段 (Sun方法)
				它不会在目标文件中包含任何跟模板相关的代码,只将这些符号标记成"未定义" 到链接阶段,链接器将所有模板实例化函数对应的未定义符号收集在一起，然后为它们生成相应的机器码
				
				优点:节省每个目标文件所点的空间大小
				缺点:链接器必须跟踪头文件所包含的源代码，还必须在链接阶段调用C++编译器,这会减慢链接速度
