####################################
####
####CreateDate:2016.1.15 21:00:00
####Author:Norman
####Descript:
####################################

####工作流程 
	1.获取exec系统调用并从调用的地址阻止它执行
	2.查询CPU的寄存器来获得处理器指令及栈的地址
	3.获取clone或fork 事件来检测新线程
	4.查看并改变数据地址读取并改变内存的变量
	5.调试器还会处理符号   链接源程序和二进制文件等.....
	
	
####断点:
	断点并不是pstrace API的一部分
	设置断点:
		1.调试器读取ptrace追踪存在地址里的二进制指令,并保存在它自己的数据结构中
		2.它在这个位置写入一个不合法的指令,不管指令是什么,只要不合法的
		3.当被调试的程序运行到这个不合法指令时,(处理器将内存中的内容设置好时) 它不会继续运行
		4.现代多任务系统中,一个不合法指令不会使整个系统崩溃掉,但是会通过引发一个中断(或错误)把控制权交回给系统内核
		5.这个中断被Linux翻译成一个SIGTRAP信号,被发送到处理器.或发到它的父进程
		6.调试器获得信号并查看被调试程序指令指针的值。(陷入trap发生的地方)
		如果这个IP地址是在断点列表中,那就是一个调试器的断点(否则是一个进程中错误,只需要传过信号并让它崩溃)
		7.被调试程序已经停在断点,调试可以让用户来做任何事,等待时机合适继续执行
		8.为了要继续执行,这个调试器需要:
			8.1:写入正确指令来回到被调试的程序内存
			8.2:单步执行(继续执行单个CPU指令,伴随着ptrace单步执行)
			8.3:把非法指令写回去(使这个执行过程下一次可以再次停止)
			8.4:让这个执行正常运行
		